<h1 align="center">1주차 (6월 1일 - 6월 7일)</h1>

- **목표**: Kotlin 코루틴의 기본 이해 & JVM에서의 async
- **내용**:
    - Kotlin 코루틴이 등장한 배경과 기본 개념 소개
    - **`launch`**와 **`suspend`** 함수를 사용한 간단한 예제를 통해 코루틴의 기본을 실습

---

# 1장. 스레드 기반 작업의 한계와 코루틴의 등장

## Thread 클래스를 직접 다루는 방법의 한계

1. Thread 클래스를 상속한 클래스를 인스턴스화해 실행할 때마다 매번 새로운 스레드가 생성된다. **스레드는 생성 비용이 비싸기 때문에** 매번 새로운 스레드를 생성하는 것은 성능적으로 좋지 않다.
2. 스레드 생성과 관리에 대한 책임이 개발자에게 있다. 따라서 프로그램의 복잡성이 증가하며, 실수로 인해 오류나 메모리 누수를 발생시킬 가능성이 증가한다.

## Executor 프레임웍의 등장

- 개발자가 스레드를 직접 관리하는 문제 해결
- 스레드의 재사용성 높임

### 스레드풀(Thread Pool)

- 스레드의 집합

### Executor

- 스레드풀을 관리하고 사용자로부터 요청받은 작업을 각 스레드에 할당하는 시스템

### Executor 함수

- 스레드풀을 생성하고 생성된 스레드풀을 관리하는 객체를 반환받는 함수
- 스레드풀을 관리하는 객체에 작업을 제출하는 함수

### Executor 프레임웍의 한계

- 스레드 블로킹
    - 스레드가 아무것도 하지 못하고 사용될 수 없는 상태에 있는 것
- 스레드는 비싼 자원이기 때문에 사용될 수 없는 상태에 놓이는 것이 반복 → 애플리케이션의 성능 저하
- Executor의 스레드 블로킹
    - 언제 올지 모르는 값을 기다리는 `Future` 객체와 `get` 함수를 호출하면,
      스레드가 결괏값이 반환될 때까지 블로킹
    - 이는 성능상으로 심각한 문제 초래

## 기존 멀티 스레드 프로그래밍의 한계와 코루틴

### 기존 멀티 스레드 프로그래밍의 한계

- 스레드는 생성 비용과 작업을 전환하는 비용이 비싸다.
- 스레드가 아무 작업을 하지 못하고 기다려야 한다면 컴퓨터 자원의 낭비된다.
- 예시) 네트워크 요청을 한 후 응답을 기다려야 하거나 복잡한 연산을 다른 스레드로 넘긴 후 결괏값을 반환받기까지 대기해야 할 때

### 코루틴은 스레드 블로킹 문제를 어떻게 극복하는가?

- 코루틴은 작업 단위로서의 코루틴이 스레드를 사용하지 않을 때 스레드 사용 권한을 양보하는 방식으로 스레드 사용을 최적화하고 스레드가 블로킹되는 상황을 방지
- 코루틴은 스레드에 비해 생성과 전환 비용이 적게 들고 스레드에 자유롭게 뗐다 붙였다 할 수 있어 작업을 생성하고 전환하는 데 필요한 리소스와 시간이 매우 줄어듦 → **경량 스레드라고 불리는 이유**
- 그 외 구조화된 동시성, 예외 처리, 스레드를 쉽게 전환할 수 있는 점 등 많은 장점이 있음!