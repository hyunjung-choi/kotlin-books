## Kotlin IN ACTION

### 1장. 코틀린이란 무엇이며, 왜 필요한가?

 - [X] 1.1 코틀린 맛보기
 - [X] 1.2 코틀린의 주요 특성
 - [X] 1.3 코틀린 응용
 - [X] 1.4 코틀린의 철학
 - [X] 1.5 코틀린 도구 사용
 - [X] 1.6 요약

### 2장. 코틀린 기초

 - [X] 2.1 기본 요소: 함수와 변수
 - [X] 2.2 클래스와 프로퍼티
 - [X] 2.3 선택 표현과 처리: enum과 when
 - [X] 2.4 대상을 이터레이션: while과 for루프
 - [X] 2.5 코틀린의 예외 처리
 - [X] 2.6 요약

### 3장. 함수 정의와 호출

 - [X] 3.1 코틀린에서 컬렉션 만들기
 - [X] 3.2 함수를 호출하기 쉽게 만들기
 - [X] 3.3 메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티
 - [ ] 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원
 - [ ] 3.5 문자열과 정규식 다루기
 - [ ] 3.6 코드 다듬기: 로컬 함수와 확장
 - [ ] 3.7 요약

### 4장. 클래스, 객체, 인터페이스

 - [ ] 4.1 클래스 계층 정의
 - [ ] 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
 - [ ] 4.3 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임
 - [ ] 4.4 object 키워드: 클래스 선언과 인스턴스 생성
 - [ ] 4.5 요약

### 5장. 람다로 프로그래밍

 - [ ] 5.1 람다 식과 멤버 참조
 - [ ] 5.2 컬렉션 함수형 API
 - [ ] 5.3 지연 계산(lazy) 컬렉션 연산
 - [ ] 5.4 자바 함수형 인터페이스 활용
 - [ ] 5.5 수신 객체 지정 람다: with와 apply
 - [ ] 5.6 요약

### 6장. 코틀린 타입 시스템

 - [ ] 6.1 널 가능성
 - [ ] 6.2 코틀린의 원시 타입
 - [ ] 6.3 컬렉션과 배열
 - [ ] 6.4 요약

### 7장. 연산자 오버로딩과 기타 관례

 - [ ] 7.1 산술 연산자 오버로딩
 - [ ] 7.2 비교 연산자 오버로딩
 - [ ] 7.3 컬렉션과 범위에 대해 쓸 수 있는 관례
 - [ ] 7.4 구조 분해 선언과 component 함수
 - [ ] 7.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티
 - [ ] 7.6 요약

### 8장. 고차 함수: 파라미터와 반환 값으로 람다 사용

 - [ ] 8.1 고차 함수 정의
 - [ ] 8.2 인라인 함수: 람다의 부가 비용 없애기
 - [ ] 8.3 고차 함수 안에서 흐름 제어
 - [ ] 8.4 요약

### 9장. 제네릭스

 - [ ] 9.1 제네릭 타입 파라미터
 - [ ] 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
 - [ ] 9.3 변성: 제네릭과 하위 타입
 - [ ] 9.4 요약

### 10장. 애노테이션과 리플렉션

 - [ ] 10.1 애노테이션 선언과 적용
 - [ ] 10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰
 - [ ] 10.3 요약

### 11장. DSL 만들기

 - [ ] 11.1 API에서 DSL로
 - [ ] 11.2 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용
 - [ ] 11.3 invoke 관례를 사용한 더 유연한 블록 중첩
 - [ ] 11.4 실전 코틀린 DSL
 - [ ] 11.5 요약
