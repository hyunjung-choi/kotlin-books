## 1.3 코틀린 응용

### 1.3.1 코틀린 서버 프로그래밍

코틀린은 새로운 컴포넌트를 작성하거나 기존 서비스 코드를 코틀린으로 이식해야 하는 경우에 모두 잘 들어맞는다. 자바 클래스를 코틀린으로 확장해도 아무 문제가 없으며, 코틀린 클래스 안의 메소드가 필드에 특정 annotation을 붙여야 하는 경우에도 아무 문제가 없다.

코틀린에는 새로운 서버 시스템 개발 기술이 있다.

예를 들어 코틀린의 Builder pattern을 활용하면 간결한 구문을 사용해 객체로 이뤄진 그래프를 쉽게 구축하면서도 코틀린이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다.

(이하 예제 코드가 몇 가지 있으나, 서버 프로그래밍 지식이 부족하기에 생략합니다. 😢)

### 1.3.2 코틀린 안드로이드 프로그래밍

**코틀린 언어의 특성**과 **안드로이드 프레임워크의 특별한 컴파일러 플러그인 지원**을 조합하면 안드로이드 애플리케이션 **생산성을 더 높일 수 있다.**

- **안코(Anko) 라이브러리**를 사용하면 수많은 안드로이드 API에 대한 코틀린 어댑터를 제공받을 수 있다.
    
    ```kotlin
    verticalLayout {
        val name = editText()
        button("Say Hello") {
            onClick { toast("Hello, ${name.text}!" }
        }
    }
    ```
    
- **애플리케이션의 신뢰성이 더 높아진다.**
코틀린 타입 시스템은 null 값을 정확히 추적하여 널 포인터로 인해 생기는 문제를 줄여준다.
따라서 자바의 NPE를 일으키는 유형의 코드는 코틀린에서 컴파일 되지도 않는다.

- **코틀린은 자바6과 완전이 호환된다.**
호환성관 관련한 새로운 문제를 야기하지 않는다.

- **성능 측면에서 아무 손해가 없다.**
코틀린 컴파일러가 생성한 바이트코드는 일반 자바 코드와 똑같이 효율적으로 실행된다.
코틀린의 런타임 시스템은 상당히 작기 때문에 컴파일 후 패키징한 애플리케이션 크기도 자바 애플리케이션에 비해 그리 많이 늘어나지 않는다. 
또한 코틀린의 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝(inlining)한다. 
⇒ 객체가 생성되지 않으므로 가비지 컬렉션이 늘어나서 프로그램 멈추는 일 X