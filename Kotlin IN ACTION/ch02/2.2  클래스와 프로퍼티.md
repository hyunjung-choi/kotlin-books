# 2.2 클래스와 프로퍼티

```java
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

이것을 자바-코틀린 변환기로 변환해보자.

```kotlin
class Person(val name: String)
```

이런 유형의 코드가 없이 데이터만 저장하는 클래스를 값 객체(value object)라 부른다.

코틀린의 기본 가시성은 `public` 이므로 변경자가 생략되었다.

## 2.2.1 프로퍼티

자바에서는 **필드와 접근자를 한데 묶어 프로퍼티(property)** 라고 부르며, 프로퍼티라는 개념을 활용하는 프레임워크가 많다.

**코틀린의 프로퍼티**

- 언어 기본 기능으로 제공
- 자바의 필드와 접근자 메소드를 완전히 대신함
- 프로퍼티를 선언할때는 `val` 또는 `var` 사용

```kotlin
class Person(
    val name: String, // 읽기 전용 프로퍼티. (비공개) 필드와 (공개) 게터를 만듦.
    var isMarried: Boolean // 쓸 수 있는 프로퍼티. (비공개)필드, (공개) 게터, (공개) 세터
)
```

코틀린의 `name` 프로퍼티를 자바 쪽에서는 `getName`이라는 이름으로 불 수 있다. 

BUT 게터와 세터의 이름을 정하는 규칙에는 예외가 있다.

**이름이 is로 시작하는 프로퍼티의 게터에는 get이 붙이 않고 원래 이름 그대로 사용**하며, **세터에는 is를 set으로 바꾼 이름을 사용**한다. 따라서 자바에서 `isMarried` 프로퍼티의 게터를 호출하려면 `isMarried()` 를 사용해야 한다.

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다. 이를 **프로퍼티를 뒷받침하는 필드(backing field)**라고 부른다. 하지만 원한다면 프로퍼티 값을 그때그때 계산할 수도 있다. 커스텀 게터를 작성하면 된다.

## 2.2.2 커스텀 접근자

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```

`isSquare` 프로퍼티에는 자체 값을 저장하는 필드가 필요 없다.

이 프로퍼티에는 자체 구현을 제공하는 게터만 존재.

클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산한다.

`get() = height == width` 로 사용해도 무방.

파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식 중 어느 쪽이 더 나을까?

두 방식 모두 비슷하다. 구현이나 성능상 차이는 없다.

차이가 나는 부분은 가독성뿐이다. 일반적으로 클래스의 특성을 정의하고 싶다면 프로퍼티로 그 특성을 정의해야 한다.

## 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

- 코틀린에서는 클래스 임포트와 함수 임포트의 차이가 없다.
- 모든 선언을 `import` 키워드로 가져올 수 있다.
- 최상위 함수는 그 이름을 써서 임포트할 수 있다.
- 패키지 이름 뒤에 `.*` 를 추가하면 패키지 안의 모든 선언을 임포트할 수 있다. 이런 스타 임포트를 사용하면 패키지 안에 있는 모든 클래스 뿐만 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다는 점에 유의하자.
- 코틀린은 여러 클래스를 한 파일에 넣을 수 있고, 파일 이름도 마음대로 정할 수 있다.
- 하지만 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.
